// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package helpers

import (
	"github.com/volatiletech/null"
	"github.com/wednesday-solutions/go-boiler/gqlgen/helper"
	"github.com/wednesday-solutions/go-boiler/graphql_models"
	"github.com/wednesday-solutions/go-boiler/models"
)

func alreadyConverted(roots []interface{}, check interface{}) bool {
	var matched int
	for _, root := range roots {
		if root == check {
			matched++
		}
	}
	return matched > 2
}

func CommentWithIntID(id int) *graphql_models.Comment {
	return &graphql_models.Comment{
		ID: CommentIDToGraphQL(id),
	}
}

func CommentWithNullDotIntID(id null.Int) *graphql_models.Comment {
	return CommentWithIntID(id.Int)
}

func CommentsToGraphQL(am []*models.Comment, roots []interface{}, recursive int) []*graphql_models.Comment {
	ar := make([]*graphql_models.Comment, len(am))
	for i, m := range am {
		ar[i] = CommentToGraphQL(m, append(roots, m), recursive+1)
	}
	return ar
}

func CommentIDToGraphQL(v int) string {
	return helper.IDToGraphQL(v, models.TableNames.Comments)
}

func CommentToGraphQL(m *models.Comment, roots []interface{}, recursive int) *graphql_models.Comment {
	if m == nil {
		return nil
	}

	r := &graphql_models.Comment{
		ID:        CommentIDToGraphQL(m.ID),
		Title:     m.Title,
		Body:      m.Body,
		CreatedAt: helper.NullDotTimeToPointerInt(m.CreatedAt),
		UpdatedAt: helper.NullDotTimeToPointerInt(m.UpdatedAt),
		DeletedAt: helper.NullDotTimeToPointerInt(m.DeletedAt),
	}

	if recursive > 3 {
		return r
	}

	if helper.IntIsFilled(m.UserID) {
		if m.R != nil && m.R.User != nil {
			if !alreadyConverted(roots, m.R.User) {
				r.User = UserToGraphQL(m.R.User, append(roots, m.R.User), recursive+1)
			}
		} else {
			r.User = UserWithIntID(m.UserID)
		}
	}

	if helper.IntIsFilled(m.PostID) {
		if m.R != nil && m.R.Post != nil {
			if !alreadyConverted(roots, m.R.Post) {
				r.Post = PostToGraphQL(m.R.Post, append(roots, m.R.Post), recursive+1)
			}
		} else {
			r.Post = PostWithIntID(m.PostID)
		}
	}

	return r
}

func CommentID(v string) int {
	return helper.IDToBoiler(v)
}

func CommentIDs(a []string) []int {
	return helper.IDsToBoiler(a)
}

func CompanyWithIntID(id int) *graphql_models.Company {
	return &graphql_models.Company{
		ID: CompanyIDToGraphQL(id),
	}
}

func CompanyWithNullDotIntID(id null.Int) *graphql_models.Company {
	return CompanyWithIntID(id.Int)
}

func CompaniesToGraphQL(am []*models.Company, roots []interface{}, recursive int) []*graphql_models.Company {
	ar := make([]*graphql_models.Company, len(am))
	for i, m := range am {
		ar[i] = CompanyToGraphQL(m, append(roots, m), recursive+1)
	}
	return ar
}

func CompanyIDToGraphQL(v int) string {
	return helper.IDToGraphQL(v, models.TableNames.Companies)
}

func CompanyToGraphQL(m *models.Company, roots []interface{}, recursive int) *graphql_models.Company {
	if m == nil {
		return nil
	}

	r := &graphql_models.Company{
		ID:        CompanyIDToGraphQL(m.ID),
		Name:      helper.NullDotStringToPointerString(m.Name),
		Active:    helper.NullDotBoolToPointerBool(m.Active),
		UpdatedAt: helper.NullDotTimeToPointerInt(m.UpdatedAt),
		DeletedAt: helper.NullDotTimeToPointerInt(m.DeletedAt),
		CreatedAt: helper.NullDotTimeToPointerInt(m.CreatedAt),
	}

	if recursive > 3 {
		return r
	}

	if m.R != nil && m.R.Locations != nil {
		r.Locations = LocationsToGraphQL(m.R.Locations, append(roots, m.R.Locations), recursive+1)
	}
	if m.R != nil && m.R.Users != nil {
		r.Users = UsersToGraphQL(m.R.Users, append(roots, m.R.Users), recursive+1)
	}

	return r
}

func CompanyID(v string) int {
	return helper.IDToBoiler(v)
}

func CompanyIDs(a []string) []int {
	return helper.IDsToBoiler(a)
}

func FollowerWithIntID(id int) *graphql_models.Follower {
	return &graphql_models.Follower{
		ID: FollowerIDToGraphQL(id),
	}
}

func FollowerWithNullDotIntID(id null.Int) *graphql_models.Follower {
	return FollowerWithIntID(id.Int)
}

func FollowersToGraphQL(am []*models.Follower, roots []interface{}, recursive int) []*graphql_models.Follower {
	ar := make([]*graphql_models.Follower, len(am))
	for i, m := range am {
		ar[i] = FollowerToGraphQL(m, append(roots, m), recursive+1)
	}
	return ar
}

func FollowerIDToGraphQL(v int) string {
	return helper.IDToGraphQL(v, models.TableNames.Followers)
}

func FollowerToGraphQL(m *models.Follower, roots []interface{}, recursive int) *graphql_models.Follower {
	if m == nil {
		return nil
	}

	r := &graphql_models.Follower{
		ID:        FollowerIDToGraphQL(m.ID),
		DeletedAt: helper.NullDotTimeToPointerInt(m.DeletedAt),
		UpdatedAt: helper.NullDotTimeToPointerInt(m.UpdatedAt),
		CreatedAt: helper.NullDotTimeToPointerInt(m.CreatedAt),
	}

	if recursive > 3 {
		return r
	}

	if helper.IntIsFilled(m.FollowerID) {
		if m.R != nil && m.R.Follower != nil {
			if !alreadyConverted(roots, m.R.Follower) {
				r.Follower = UserToGraphQL(m.R.Follower, append(roots, m.R.Follower), recursive+1)
			}
		} else {
			r.Follower = UserWithIntID(m.FollowerID)
		}
	}

	if helper.IntIsFilled(m.FolloweeID) {
		if m.R != nil && m.R.Followee != nil {
			if !alreadyConverted(roots, m.R.Followee) {
				r.Followee = UserToGraphQL(m.R.Followee, append(roots, m.R.Followee), recursive+1)
			}
		} else {
			r.Followee = UserWithIntID(m.FolloweeID)
		}
	}

	return r
}

func FollowerID(v string) int {
	return helper.IDToBoiler(v)
}

func FollowerIDs(a []string) []int {
	return helper.IDsToBoiler(a)
}

func LocationWithIntID(id int) *graphql_models.Location {
	return &graphql_models.Location{
		ID: LocationIDToGraphQL(id),
	}
}

func LocationWithNullDotIntID(id null.Int) *graphql_models.Location {
	return LocationWithIntID(id.Int)
}

func LocationsToGraphQL(am []*models.Location, roots []interface{}, recursive int) []*graphql_models.Location {
	ar := make([]*graphql_models.Location, len(am))
	for i, m := range am {
		ar[i] = LocationToGraphQL(m, append(roots, m), recursive+1)
	}
	return ar
}

func LocationIDToGraphQL(v int) string {
	return helper.IDToGraphQL(v, models.TableNames.Locations)
}

func LocationToGraphQL(m *models.Location, roots []interface{}, recursive int) *graphql_models.Location {
	if m == nil {
		return nil
	}

	r := &graphql_models.Location{
		ID:        LocationIDToGraphQL(m.ID),
		Name:      helper.NullDotStringToPointerString(m.Name),
		Active:    helper.NullDotBoolToPointerBool(m.Active),
		Address:   helper.NullDotStringToPointerString(m.Address),
		UpdatedAt: helper.NullDotTimeToPointerInt(m.UpdatedAt),
		DeletedAt: helper.NullDotTimeToPointerInt(m.DeletedAt),
		CreatedAt: helper.NullDotTimeToPointerInt(m.CreatedAt),
	}

	if recursive > 3 {
		return r
	}

	if helper.IntIsFilled(m.CompanyID) {
		if m.R != nil && m.R.Company != nil {
			if !alreadyConverted(roots, m.R.Company) {
				r.Company = CompanyToGraphQL(m.R.Company, append(roots, m.R.Company), recursive+1)
			}
		} else {
			r.Company = CompanyWithIntID(m.CompanyID)
		}
	}
	if m.R != nil && m.R.Users != nil {
		r.Users = UsersToGraphQL(m.R.Users, append(roots, m.R.Users), recursive+1)
	}

	return r
}

func LocationID(v string) int {
	return helper.IDToBoiler(v)
}

func LocationIDs(a []string) []int {
	return helper.IDsToBoiler(a)
}

func PostWithIntID(id int) *graphql_models.Post {
	return &graphql_models.Post{
		ID: PostIDToGraphQL(id),
	}
}

func PostWithNullDotIntID(id null.Int) *graphql_models.Post {
	return PostWithIntID(id.Int)
}

func PostsToGraphQL(am []*models.Post, roots []interface{}, recursive int) []*graphql_models.Post {
	ar := make([]*graphql_models.Post, len(am))
	for i, m := range am {
		ar[i] = PostToGraphQL(m, append(roots, m), recursive+1)
	}
	return ar
}

func PostIDToGraphQL(v int) string {
	return helper.IDToGraphQL(v, models.TableNames.Posts)
}

func PostToGraphQL(m *models.Post, roots []interface{}, recursive int) *graphql_models.Post {
	if m == nil {
		return nil
	}

	r := &graphql_models.Post{
		ID:        PostIDToGraphQL(m.ID),
		Title:     m.Title,
		Body:      m.Body,
		DeletedAt: helper.NullDotTimeToPointerInt(m.DeletedAt),
		CreatedAt: helper.NullDotTimeToPointerInt(m.CreatedAt),
		UpdatedAt: helper.NullDotTimeToPointerInt(m.UpdatedAt),
	}

	if recursive > 3 {
		return r
	}

	if helper.IntIsFilled(m.UserID) {
		if m.R != nil && m.R.User != nil {
			if !alreadyConverted(roots, m.R.User) {
				r.User = UserToGraphQL(m.R.User, append(roots, m.R.User), recursive+1)
			}
		} else {
			r.User = UserWithIntID(m.UserID)
		}
	}
	if m.R != nil && m.R.Comments != nil {
		r.Comments = CommentsToGraphQL(m.R.Comments, append(roots, m.R.Comments), recursive+1)
	}

	return r
}

func PostID(v string) int {
	return helper.IDToBoiler(v)
}

func PostIDs(a []string) []int {
	return helper.IDsToBoiler(a)
}

func RoleWithIntID(id int) *graphql_models.Role {
	return &graphql_models.Role{
		ID: RoleIDToGraphQL(id),
	}
}

func RoleWithNullDotIntID(id null.Int) *graphql_models.Role {
	return RoleWithIntID(id.Int)
}

func RolesToGraphQL(am []*models.Role, roots []interface{}, recursive int) []*graphql_models.Role {
	ar := make([]*graphql_models.Role, len(am))
	for i, m := range am {
		ar[i] = RoleToGraphQL(m, append(roots, m), recursive+1)
	}
	return ar
}

func RoleIDToGraphQL(v int) string {
	return helper.IDToGraphQL(v, models.TableNames.Roles)
}

func RoleToGraphQL(m *models.Role, roots []interface{}, recursive int) *graphql_models.Role {
	if m == nil {
		return nil
	}

	r := &graphql_models.Role{
		ID:          RoleIDToGraphQL(m.ID),
		AccessLevel: m.AccessLevel,
		Name:        m.Name,
		UpdatedAt:   helper.NullDotTimeToPointerInt(m.UpdatedAt),
		DeletedAt:   helper.NullDotTimeToPointerInt(m.DeletedAt),
		CreatedAt:   helper.NullDotTimeToPointerInt(m.CreatedAt),
	}

	if recursive > 3 {
		return r
	}

	if m.R != nil && m.R.Users != nil {
		r.Users = UsersToGraphQL(m.R.Users, append(roots, m.R.Users), recursive+1)
	}

	return r
}

func RoleID(v string) int {
	return helper.IDToBoiler(v)
}

func RoleIDs(a []string) []int {
	return helper.IDsToBoiler(a)
}

func UserWithIntID(id int) *graphql_models.User {
	return &graphql_models.User{
		ID: UserIDToGraphQL(id),
	}
}

func UserWithNullDotIntID(id null.Int) *graphql_models.User {
	return UserWithIntID(id.Int)
}

func UsersToGraphQL(am []*models.User, roots []interface{}, recursive int) []*graphql_models.User {
	ar := make([]*graphql_models.User, len(am))
	for i, m := range am {
		ar[i] = UserToGraphQL(m, append(roots, m), recursive+1)
	}
	return ar
}

func UserIDToGraphQL(v int) string {
	return helper.IDToGraphQL(v, models.TableNames.Users)
}

func UserToGraphQL(m *models.User, roots []interface{}, recursive int) *graphql_models.User {
	if m == nil {
		return nil
	}

	r := &graphql_models.User{
		ID:                 UserIDToGraphQL(m.ID),
		FirstName:          helper.NullDotStringToPointerString(m.FirstName),
		LastName:           helper.NullDotStringToPointerString(m.LastName),
		Username:           helper.NullDotStringToPointerString(m.Username),
		Password:           helper.NullDotStringToPointerString(m.Password),
		Email:              helper.NullDotStringToPointerString(m.Email),
		Mobile:             helper.NullDotStringToPointerString(m.Mobile),
		Phone:              helper.NullDotStringToPointerString(m.Phone),
		Address:            helper.NullDotStringToPointerString(m.Address),
		Active:             helper.NullDotBoolToPointerBool(m.Active),
		LastLogin:          helper.NullDotTimeToPointerInt(m.LastLogin),
		LastPasswordChange: helper.NullDotTimeToPointerInt(m.LastPasswordChange),
		Token:              helper.NullDotStringToPointerString(m.Token),
		CreatedAt:          helper.NullDotTimeToPointerInt(m.CreatedAt),
		DeletedAt:          helper.NullDotTimeToPointerInt(m.DeletedAt),
		UpdatedAt:          helper.NullDotTimeToPointerInt(m.UpdatedAt),
	}

	if recursive > 3 {
		return r
	}

	if helper.NullDotIntIsFilled(m.RoleID) {
		if m.R != nil && m.R.Role != nil {
			if !alreadyConverted(roots, m.R.Role) {
				r.Role = RoleToGraphQL(m.R.Role, append(roots, m.R.Role), recursive+1)
			}
		} else {
			r.Role = RoleWithNullDotIntID(m.RoleID)
		}
	}

	if helper.NullDotIntIsFilled(m.CompanyID) {
		if m.R != nil && m.R.Company != nil {
			if !alreadyConverted(roots, m.R.Company) {
				r.Company = CompanyToGraphQL(m.R.Company, append(roots, m.R.Company), recursive+1)
			}
		} else {
			r.Company = CompanyWithNullDotIntID(m.CompanyID)
		}
	}

	if helper.NullDotIntIsFilled(m.LocationID) {
		if m.R != nil && m.R.Location != nil {
			if !alreadyConverted(roots, m.R.Location) {
				r.Location = LocationToGraphQL(m.R.Location, append(roots, m.R.Location), recursive+1)
			}
		} else {
			r.Location = LocationWithNullDotIntID(m.LocationID)
		}
	}
	if m.R != nil && m.R.Comments != nil {
		r.Comments = CommentsToGraphQL(m.R.Comments, append(roots, m.R.Comments), recursive+1)
	}
	if m.R != nil && m.R.FolloweeFollowers != nil {
		r.FolloweeFollowers = FollowersToGraphQL(m.R.FolloweeFollowers, append(roots, m.R.FolloweeFollowers), recursive+1)
	}
	if m.R != nil && m.R.FollowerFollowers != nil {
		r.FollowerFollowers = FollowersToGraphQL(m.R.FollowerFollowers, append(roots, m.R.FollowerFollowers), recursive+1)
	}
	if m.R != nil && m.R.Posts != nil {
		r.Posts = PostsToGraphQL(m.R.Posts, append(roots, m.R.Posts), recursive+1)
	}

	return r
}

func UserID(v string) int {
	return helper.IDToBoiler(v)
}

func UserIDs(a []string) []int {
	return helper.IDsToBoiler(a)
}
