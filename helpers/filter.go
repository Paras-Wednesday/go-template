// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package helpers

import (
	"fmt"
	"strings"

	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/wednesday-solutions/go-boiler/gqlgen/helper"
	"github.com/wednesday-solutions/go-boiler/graphql_models"
	"github.com/wednesday-solutions/go-boiler/models"
)

// const regexSign = `'`
const percentSign = `%`

func startsWithValue(v string) string { return v + percentSign }
func endsWithValue(v string) string   { return percentSign + v }
func containsValue(v string) string   { return percentSign + v + percentSign }

const isLike = " LIKE ?"
const in = " IN ?"
const notIn = " NOT IN ?"

func appendSubQuery(queryMods []qm.QueryMod, q *queries.Query) []qm.QueryMod {
	qs, args := queries.BuildQuery(q)
	qsClean := strings.TrimSuffix(qs, ";")
	return append(queryMods, qm.Where(fmt.Sprintf("EXISTS(%v)", qsClean), args...))
}

func IDFilterToMods(m *graphql_models.IDFilter, column string) []qm.QueryMod {
	if m == nil {
		return nil
	}
	var queryMods []qm.QueryMod
	if m.EqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.EQ, helper.IDToBoiler(*m.EqualTo)))
	}
	if m.NotEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.NEQ, helper.IDToBoiler(*m.NotEqualTo)))
	}
	if len(m.In) > 0 {
		queryMods = append(queryMods, qm.WhereIn(column+in, helper.IDsToBoilerInterfaces(m.In)...))
	}
	if len(m.NotIn) > 0 {
		queryMods = append(queryMods, qm.WhereIn(column+notIn, helper.IDsToBoilerInterfaces(m.NotIn)...))
	}
	return queryMods
}

func StringFilterToMods(m *graphql_models.StringFilter, column string) []qm.QueryMod {
	if m == nil {
		return nil
	}

	var queryMods []qm.QueryMod
	if m.EqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.EQ, *m.EqualTo))
	}
	if m.NotEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.NEQ, *m.NotEqualTo))
	}

	lowerColumn := "LOWER(" + column + ")"
	if m.StartWith != nil {
		queryMods = append(queryMods, qm.Where(lowerColumn+isLike, startsWithValue(strings.ToLower(*m.StartWith))))
	}
	if m.EndWith != nil {
		queryMods = append(queryMods, qm.Where(lowerColumn+isLike, endsWithValue(strings.ToLower(*m.EndWith))))
	}
	if m.Contain != nil {
		queryMods = append(queryMods, qm.Where(lowerColumn+isLike, containsValue(strings.ToLower(*m.Contain))))
	}

	if m.StartWithStrict != nil {
		queryMods = append(queryMods, qm.Where(column+isLike, startsWithValue(*m.StartWithStrict)))
	}
	if m.EndWithStrict != nil {
		queryMods = append(queryMods, qm.Where(column+isLike, endsWithValue(*m.EndWithStrict)))
	}
	if m.ContainStrict != nil {
		queryMods = append(queryMods, qm.Where(column+isLike, containsValue(*m.ContainStrict)))
	}

	if len(m.In) > 0 {
		queryMods = append(queryMods, qm.WhereIn(column+in, helper.IDsToBoilerInterfaces(m.In)...))
	}
	if len(m.NotIn) > 0 {
		queryMods = append(queryMods, qm.WhereIn(column+notIn, helper.IDsToBoilerInterfaces(m.NotIn)...))
	}

	return queryMods
}

func IntFilterToMods(m *graphql_models.IntFilter, column string) []qm.QueryMod {
	if m == nil {
		return nil
	}
	var queryMods []qm.QueryMod
	if m.EqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.EQ, *m.EqualTo))
	}
	if m.NotEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.NEQ, *m.NotEqualTo))
	}
	if m.LessThan != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.LT, *m.LessThan))
	}
	if m.MoreThan != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.GT, *m.MoreThan))
	}
	if m.LessThanOrEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.LTE, *m.LessThanOrEqualTo))
	}
	if m.MoreThanOrEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.GTE, *m.MoreThanOrEqualTo))
	}
	if len(m.In) > 0 {
		queryMods = append(queryMods, qm.WhereIn(column+in, helper.IntsToInterfaces(m.In)...))
	}
	if len(m.NotIn) > 0 {
		queryMods = append(queryMods, qm.WhereIn(column+notIn, helper.IntsToInterfaces(m.NotIn)...))
	}
	return queryMods
}

func FloatFilterToMods(m *graphql_models.FloatFilter, column string) []qm.QueryMod {
	if m == nil {
		return nil
	}
	var queryMods []qm.QueryMod
	if m.EqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.EQ, *m.EqualTo))
	}
	if m.NotEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.NEQ, *m.NotEqualTo))
	}
	if m.LessThan != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.LT, *m.LessThan))
	}
	if m.MoreThan != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.GT, *m.MoreThan))
	}
	if m.LessThanOrEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.LTE, *m.LessThanOrEqualTo))
	}
	if m.MoreThanOrEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.GTE, *m.MoreThanOrEqualTo))
	}
	if len(m.In) > 0 {
		queryMods = append(queryMods, qm.WhereIn(column+in, helper.FloatsToInterfaces(m.In)...))
	}
	if len(m.NotIn) > 0 {
		queryMods = append(queryMods, qm.WhereIn(column+notIn, helper.FloatsToInterfaces(m.NotIn)...))
	}
	return queryMods
}

func BooleanFilterToMods(m *graphql_models.BooleanFilter, column string) []qm.QueryMod {
	if m == nil {
		return nil
	}
	var queryMods []qm.QueryMod
	if m.IsTrue != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.EQ, *m.IsTrue))
	}
	if m.IsFalse != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.NEQ, *m.IsFalse))
	}
	if m.IsNull != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.NEQ, *m.IsNull))
	}
	return queryMods
}

func CommentFilterToMods(m *graphql_models.CommentFilter) []qm.QueryMod {
	if m == nil {
		return nil
	}
	if m.Search != nil || m.Where != nil {
		var queryMods []qm.QueryMod
		queryMods = append(queryMods, CommentSearchToMods(m.Search)...)
		queryMods = append(queryMods, CommentWhereToMods(m.Where, true)...)
		if len(queryMods) > 0 {
			return []qm.QueryMod{
				qm.Expr(queryMods...),
			}
		}
	}
	return nil
}
func CommentSearchToMods(search *string) []qm.QueryMod {
	// TODO: implement your own custom search here
	return nil
}

func CommentPaginationToMods(m *graphql_models.CommentPagination) []qm.QueryMod {
	if m == nil {
		return nil
	}
	if m.Limit != 0 {
		var queryMods []qm.QueryMod
		queryMods = append(queryMods, qm.Limit(m.Limit), qm.Offset(m.Page*m.Limit))
		return queryMods
	}
	return nil
}

func CommentWhereSubqueryToMods(m *graphql_models.CommentWhere, foreignColumn string) []qm.QueryMod {
	if m == nil {
		return nil
	}
	var queryMods []qm.QueryMod
	queryMods = append(queryMods)

	// if foreign key exist so we can filter on ID in the root table instead of subquery
	hasForeignKeyInRoot := foreignColumn != ""
	if hasForeignKeyInRoot {
		queryMods = append(queryMods, IDFilterToMods(m.ID, foreignColumn)...)
	}

	subQueryMods := CommentWhereToMods(m, !hasForeignKeyInRoot)
	if len(subQueryMods) > 0 {
		subQuery := models.Comments(append(subQueryMods, qm.Select("1"))...)
		queryMods = appendSubQuery(queryMods, subQuery.Query)
	}
	return queryMods
}

func CommentWhereToMods(m *graphql_models.CommentWhere, withPrimaryID bool) []qm.QueryMod {
	if m == nil {
		return nil
	}
	var queryMods []qm.QueryMod

	if withPrimaryID {
		queryMods = append(queryMods, IDFilterToMods(m.ID, models.CommentColumns.ID)...)
	}
	queryMods = append(queryMods, UserWhereSubqueryToMods(m.User, models.CommentColumns.UserID)...)
	queryMods = append(queryMods, PostWhereSubqueryToMods(m.Post, models.CommentColumns.PostID)...)
	queryMods = append(queryMods, StringFilterToMods(m.Title, models.CommentColumns.Title)...)
	queryMods = append(queryMods, StringFilterToMods(m.Body, models.CommentColumns.Body)...)
	queryMods = append(queryMods, IntFilterToMods(m.CreatedAt, models.CommentColumns.CreatedAt)...)
	queryMods = append(queryMods, IntFilterToMods(m.UpdatedAt, models.CommentColumns.UpdatedAt)...)
	queryMods = append(queryMods, IntFilterToMods(m.DeletedAt, models.CommentColumns.DeletedAt)...)
	if m.Or != nil {
		queryMods = append(queryMods, qm.Or2(qm.Expr(CommentWhereToMods(m.Or, true)...)))
	}
	if m.And != nil {
		queryMods = append(queryMods, qm.Expr(CommentWhereToMods(m.And, true)...))
	}
	return queryMods
}

func CompanyFilterToMods(m *graphql_models.CompanyFilter) []qm.QueryMod {
	if m == nil {
		return nil
	}
	if m.Search != nil || m.Where != nil {
		var queryMods []qm.QueryMod
		queryMods = append(queryMods, CompanySearchToMods(m.Search)...)
		queryMods = append(queryMods, CompanyWhereToMods(m.Where, true)...)
		if len(queryMods) > 0 {
			return []qm.QueryMod{
				qm.Expr(queryMods...),
			}
		}
	}
	return nil
}
func CompanySearchToMods(search *string) []qm.QueryMod {
	// TODO: implement your own custom search here
	return nil
}

func CompanyPaginationToMods(m *graphql_models.CompanyPagination) []qm.QueryMod {
	if m == nil {
		return nil
	}
	if m.Limit != 0 {
		var queryMods []qm.QueryMod
		queryMods = append(queryMods, qm.Limit(m.Limit), qm.Offset(m.Page*m.Limit))
		return queryMods
	}
	return nil
}

func CompanyWhereSubqueryToMods(m *graphql_models.CompanyWhere, foreignColumn string) []qm.QueryMod {
	if m == nil {
		return nil
	}
	var queryMods []qm.QueryMod
	queryMods = append(queryMods)

	// if foreign key exist so we can filter on ID in the root table instead of subquery
	hasForeignKeyInRoot := foreignColumn != ""
	if hasForeignKeyInRoot {
		queryMods = append(queryMods, IDFilterToMods(m.ID, foreignColumn)...)
	}

	subQueryMods := CompanyWhereToMods(m, !hasForeignKeyInRoot)
	if len(subQueryMods) > 0 {
		subQuery := models.Companies(append(subQueryMods, qm.Select("1"))...)
		queryMods = appendSubQuery(queryMods, subQuery.Query)
	}
	return queryMods
}

func CompanyWhereToMods(m *graphql_models.CompanyWhere, withPrimaryID bool) []qm.QueryMod {
	if m == nil {
		return nil
	}
	var queryMods []qm.QueryMod

	if withPrimaryID {
		queryMods = append(queryMods, IDFilterToMods(m.ID, models.CompanyColumns.ID)...)
	}
	queryMods = append(queryMods, StringFilterToMods(m.Name, models.CompanyColumns.Name)...)
	queryMods = append(queryMods, BooleanFilterToMods(m.Active, models.CompanyColumns.Active)...)
	queryMods = append(queryMods, IntFilterToMods(m.UpdatedAt, models.CompanyColumns.UpdatedAt)...)
	queryMods = append(queryMods, IntFilterToMods(m.DeletedAt, models.CompanyColumns.DeletedAt)...)
	queryMods = append(queryMods, IntFilterToMods(m.CreatedAt, models.CompanyColumns.CreatedAt)...)
	queryMods = append(queryMods, LocationWhereSubqueryToMods(m.Locations, "")...)
	queryMods = append(queryMods, UserWhereSubqueryToMods(m.Users, "")...)
	if m.Or != nil {
		queryMods = append(queryMods, qm.Or2(qm.Expr(CompanyWhereToMods(m.Or, true)...)))
	}
	if m.And != nil {
		queryMods = append(queryMods, qm.Expr(CompanyWhereToMods(m.And, true)...))
	}
	return queryMods
}

func FollowerFilterToMods(m *graphql_models.FollowerFilter) []qm.QueryMod {
	if m == nil {
		return nil
	}
	if m.Search != nil || m.Where != nil {
		var queryMods []qm.QueryMod
		queryMods = append(queryMods, FollowerSearchToMods(m.Search)...)
		queryMods = append(queryMods, FollowerWhereToMods(m.Where, true)...)
		if len(queryMods) > 0 {
			return []qm.QueryMod{
				qm.Expr(queryMods...),
			}
		}
	}
	return nil
}
func FollowerSearchToMods(search *string) []qm.QueryMod {
	// TODO: implement your own custom search here
	return nil
}

func FollowerPaginationToMods(m *graphql_models.FollowerPagination) []qm.QueryMod {
	if m == nil {
		return nil
	}
	if m.Limit != 0 {
		var queryMods []qm.QueryMod
		queryMods = append(queryMods, qm.Limit(m.Limit), qm.Offset(m.Page*m.Limit))
		return queryMods
	}
	return nil
}

func FollowerWhereSubqueryToMods(m *graphql_models.FollowerWhere, foreignColumn string) []qm.QueryMod {
	if m == nil {
		return nil
	}
	var queryMods []qm.QueryMod
	queryMods = append(queryMods)

	// if foreign key exist so we can filter on ID in the root table instead of subquery
	hasForeignKeyInRoot := foreignColumn != ""
	if hasForeignKeyInRoot {
		queryMods = append(queryMods, IDFilterToMods(m.ID, foreignColumn)...)
	}

	subQueryMods := FollowerWhereToMods(m, !hasForeignKeyInRoot)
	if len(subQueryMods) > 0 {
		subQuery := models.Followers(append(subQueryMods, qm.Select("1"))...)
		queryMods = appendSubQuery(queryMods, subQuery.Query)
	}
	return queryMods
}

func FollowerWhereToMods(m *graphql_models.FollowerWhere, withPrimaryID bool) []qm.QueryMod {
	if m == nil {
		return nil
	}
	var queryMods []qm.QueryMod

	if withPrimaryID {
		queryMods = append(queryMods, IDFilterToMods(m.ID, models.FollowerColumns.ID)...)
	}
	queryMods = append(queryMods, UserWhereSubqueryToMods(m.Follower, models.FollowerColumns.FollowerID)...)
	queryMods = append(queryMods, UserWhereSubqueryToMods(m.Followee, models.FollowerColumns.FolloweeID)...)
	queryMods = append(queryMods, IntFilterToMods(m.DeletedAt, models.FollowerColumns.DeletedAt)...)
	queryMods = append(queryMods, IntFilterToMods(m.UpdatedAt, models.FollowerColumns.UpdatedAt)...)
	queryMods = append(queryMods, IntFilterToMods(m.CreatedAt, models.FollowerColumns.CreatedAt)...)
	if m.Or != nil {
		queryMods = append(queryMods, qm.Or2(qm.Expr(FollowerWhereToMods(m.Or, true)...)))
	}
	if m.And != nil {
		queryMods = append(queryMods, qm.Expr(FollowerWhereToMods(m.And, true)...))
	}
	return queryMods
}

func LocationFilterToMods(m *graphql_models.LocationFilter) []qm.QueryMod {
	if m == nil {
		return nil
	}
	if m.Search != nil || m.Where != nil {
		var queryMods []qm.QueryMod
		queryMods = append(queryMods, LocationSearchToMods(m.Search)...)
		queryMods = append(queryMods, LocationWhereToMods(m.Where, true)...)
		if len(queryMods) > 0 {
			return []qm.QueryMod{
				qm.Expr(queryMods...),
			}
		}
	}
	return nil
}
func LocationSearchToMods(search *string) []qm.QueryMod {
	// TODO: implement your own custom search here
	return nil
}

func LocationPaginationToMods(m *graphql_models.LocationPagination) []qm.QueryMod {
	if m == nil {
		return nil
	}
	if m.Limit != 0 {
		var queryMods []qm.QueryMod
		queryMods = append(queryMods, qm.Limit(m.Limit), qm.Offset(m.Page*m.Limit))
		return queryMods
	}
	return nil
}

func LocationWhereSubqueryToMods(m *graphql_models.LocationWhere, foreignColumn string) []qm.QueryMod {
	if m == nil {
		return nil
	}
	var queryMods []qm.QueryMod
	queryMods = append(queryMods)

	// if foreign key exist so we can filter on ID in the root table instead of subquery
	hasForeignKeyInRoot := foreignColumn != ""
	if hasForeignKeyInRoot {
		queryMods = append(queryMods, IDFilterToMods(m.ID, foreignColumn)...)
	}

	subQueryMods := LocationWhereToMods(m, !hasForeignKeyInRoot)
	if len(subQueryMods) > 0 {
		subQuery := models.Locations(append(subQueryMods, qm.Select("1"))...)
		queryMods = appendSubQuery(queryMods, subQuery.Query)
	}
	return queryMods
}

func LocationWhereToMods(m *graphql_models.LocationWhere, withPrimaryID bool) []qm.QueryMod {
	if m == nil {
		return nil
	}
	var queryMods []qm.QueryMod

	if withPrimaryID {
		queryMods = append(queryMods, IDFilterToMods(m.ID, models.LocationColumns.ID)...)
	}
	queryMods = append(queryMods, StringFilterToMods(m.Name, models.LocationColumns.Name)...)
	queryMods = append(queryMods, BooleanFilterToMods(m.Active, models.LocationColumns.Active)...)
	queryMods = append(queryMods, StringFilterToMods(m.Address, models.LocationColumns.Address)...)
	queryMods = append(queryMods, CompanyWhereSubqueryToMods(m.Company, models.LocationColumns.CompanyID)...)
	queryMods = append(queryMods, IntFilterToMods(m.UpdatedAt, models.LocationColumns.UpdatedAt)...)
	queryMods = append(queryMods, IntFilterToMods(m.DeletedAt, models.LocationColumns.DeletedAt)...)
	queryMods = append(queryMods, IntFilterToMods(m.CreatedAt, models.LocationColumns.CreatedAt)...)
	queryMods = append(queryMods, UserWhereSubqueryToMods(m.Users, "")...)
	if m.Or != nil {
		queryMods = append(queryMods, qm.Or2(qm.Expr(LocationWhereToMods(m.Or, true)...)))
	}
	if m.And != nil {
		queryMods = append(queryMods, qm.Expr(LocationWhereToMods(m.And, true)...))
	}
	return queryMods
}

func PostFilterToMods(m *graphql_models.PostFilter) []qm.QueryMod {
	if m == nil {
		return nil
	}
	if m.Search != nil || m.Where != nil {
		var queryMods []qm.QueryMod
		queryMods = append(queryMods, PostSearchToMods(m.Search)...)
		queryMods = append(queryMods, PostWhereToMods(m.Where, true)...)
		if len(queryMods) > 0 {
			return []qm.QueryMod{
				qm.Expr(queryMods...),
			}
		}
	}
	return nil
}
func PostSearchToMods(search *string) []qm.QueryMod {
	// TODO: implement your own custom search here
	return nil
}

func PostPaginationToMods(m *graphql_models.PostPagination) []qm.QueryMod {
	if m == nil {
		return nil
	}
	if m.Limit != 0 {
		var queryMods []qm.QueryMod
		queryMods = append(queryMods, qm.Limit(m.Limit), qm.Offset(m.Page*m.Limit))
		return queryMods
	}
	return nil
}

func PostWhereSubqueryToMods(m *graphql_models.PostWhere, foreignColumn string) []qm.QueryMod {
	if m == nil {
		return nil
	}
	var queryMods []qm.QueryMod
	queryMods = append(queryMods)

	// if foreign key exist so we can filter on ID in the root table instead of subquery
	hasForeignKeyInRoot := foreignColumn != ""
	if hasForeignKeyInRoot {
		queryMods = append(queryMods, IDFilterToMods(m.ID, foreignColumn)...)
	}

	subQueryMods := PostWhereToMods(m, !hasForeignKeyInRoot)
	if len(subQueryMods) > 0 {
		subQuery := models.Posts(append(subQueryMods, qm.Select("1"))...)
		queryMods = appendSubQuery(queryMods, subQuery.Query)
	}
	return queryMods
}

func PostWhereToMods(m *graphql_models.PostWhere, withPrimaryID bool) []qm.QueryMod {
	if m == nil {
		return nil
	}
	var queryMods []qm.QueryMod

	if withPrimaryID {
		queryMods = append(queryMods, IDFilterToMods(m.ID, models.PostColumns.ID)...)
	}
	queryMods = append(queryMods, UserWhereSubqueryToMods(m.User, models.PostColumns.UserID)...)
	queryMods = append(queryMods, StringFilterToMods(m.Title, models.PostColumns.Title)...)
	queryMods = append(queryMods, StringFilterToMods(m.Body, models.PostColumns.Body)...)
	queryMods = append(queryMods, IntFilterToMods(m.DeletedAt, models.PostColumns.DeletedAt)...)
	queryMods = append(queryMods, IntFilterToMods(m.CreatedAt, models.PostColumns.CreatedAt)...)
	queryMods = append(queryMods, IntFilterToMods(m.UpdatedAt, models.PostColumns.UpdatedAt)...)
	queryMods = append(queryMods, CommentWhereSubqueryToMods(m.Comments, "")...)
	if m.Or != nil {
		queryMods = append(queryMods, qm.Or2(qm.Expr(PostWhereToMods(m.Or, true)...)))
	}
	if m.And != nil {
		queryMods = append(queryMods, qm.Expr(PostWhereToMods(m.And, true)...))
	}
	return queryMods
}

func RoleFilterToMods(m *graphql_models.RoleFilter) []qm.QueryMod {
	if m == nil {
		return nil
	}
	if m.Search != nil || m.Where != nil {
		var queryMods []qm.QueryMod
		queryMods = append(queryMods, RoleSearchToMods(m.Search)...)
		queryMods = append(queryMods, RoleWhereToMods(m.Where, true)...)
		if len(queryMods) > 0 {
			return []qm.QueryMod{
				qm.Expr(queryMods...),
			}
		}
	}
	return nil
}
func RoleSearchToMods(search *string) []qm.QueryMod {
	// TODO: implement your own custom search here
	return nil
}

func RolePaginationToMods(m *graphql_models.RolePagination) []qm.QueryMod {
	if m == nil {
		return nil
	}
	if m.Limit != 0 {
		var queryMods []qm.QueryMod
		queryMods = append(queryMods, qm.Limit(m.Limit), qm.Offset(m.Page*m.Limit))
		return queryMods
	}
	return nil
}

func RoleWhereSubqueryToMods(m *graphql_models.RoleWhere, foreignColumn string) []qm.QueryMod {
	if m == nil {
		return nil
	}
	var queryMods []qm.QueryMod
	queryMods = append(queryMods)

	// if foreign key exist so we can filter on ID in the root table instead of subquery
	hasForeignKeyInRoot := foreignColumn != ""
	if hasForeignKeyInRoot {
		queryMods = append(queryMods, IDFilterToMods(m.ID, foreignColumn)...)
	}

	subQueryMods := RoleWhereToMods(m, !hasForeignKeyInRoot)
	if len(subQueryMods) > 0 {
		subQuery := models.Roles(append(subQueryMods, qm.Select("1"))...)
		queryMods = appendSubQuery(queryMods, subQuery.Query)
	}
	return queryMods
}

func RoleWhereToMods(m *graphql_models.RoleWhere, withPrimaryID bool) []qm.QueryMod {
	if m == nil {
		return nil
	}
	var queryMods []qm.QueryMod

	if withPrimaryID {
		queryMods = append(queryMods, IDFilterToMods(m.ID, models.RoleColumns.ID)...)
	}
	queryMods = append(queryMods, IntFilterToMods(m.AccessLevel, models.RoleColumns.AccessLevel)...)
	queryMods = append(queryMods, StringFilterToMods(m.Name, models.RoleColumns.Name)...)
	queryMods = append(queryMods, IntFilterToMods(m.UpdatedAt, models.RoleColumns.UpdatedAt)...)
	queryMods = append(queryMods, IntFilterToMods(m.DeletedAt, models.RoleColumns.DeletedAt)...)
	queryMods = append(queryMods, IntFilterToMods(m.CreatedAt, models.RoleColumns.CreatedAt)...)
	queryMods = append(queryMods, UserWhereSubqueryToMods(m.Users, "")...)
	if m.Or != nil {
		queryMods = append(queryMods, qm.Or2(qm.Expr(RoleWhereToMods(m.Or, true)...)))
	}
	if m.And != nil {
		queryMods = append(queryMods, qm.Expr(RoleWhereToMods(m.And, true)...))
	}
	return queryMods
}

func UserFilterToMods(m *graphql_models.UserFilter) []qm.QueryMod {
	if m == nil {
		return nil
	}
	if m.Search != nil || m.Where != nil {
		var queryMods []qm.QueryMod
		queryMods = append(queryMods, UserSearchToMods(m.Search)...)
		queryMods = append(queryMods, UserWhereToMods(m.Where, true)...)
		if len(queryMods) > 0 {
			return []qm.QueryMod{
				qm.Expr(queryMods...),
			}
		}
	}
	return nil
}
func UserSearchToMods(search *string) []qm.QueryMod {
	// TODO: implement your own custom search here
	return nil
}

func UserPaginationToMods(m *graphql_models.UserPagination) []qm.QueryMod {
	if m == nil {
		return nil
	}
	if m.Limit != 0 {
		var queryMods []qm.QueryMod
		queryMods = append(queryMods, qm.Limit(m.Limit), qm.Offset(m.Page*m.Limit))
		return queryMods
	}
	return nil
}

func UserWhereSubqueryToMods(m *graphql_models.UserWhere, foreignColumn string) []qm.QueryMod {
	if m == nil {
		return nil
	}
	var queryMods []qm.QueryMod
	queryMods = append(queryMods)

	// if foreign key exist so we can filter on ID in the root table instead of subquery
	hasForeignKeyInRoot := foreignColumn != ""
	if hasForeignKeyInRoot {
		queryMods = append(queryMods, IDFilterToMods(m.ID, foreignColumn)...)
	}

	subQueryMods := UserWhereToMods(m, !hasForeignKeyInRoot)
	if len(subQueryMods) > 0 {
		subQuery := models.Users(append(subQueryMods, qm.Select("1"))...)
		queryMods = appendSubQuery(queryMods, subQuery.Query)
	}
	return queryMods
}

func UserWhereToMods(m *graphql_models.UserWhere, withPrimaryID bool) []qm.QueryMod {
	if m == nil {
		return nil
	}
	var queryMods []qm.QueryMod

	if withPrimaryID {
		queryMods = append(queryMods, IDFilterToMods(m.ID, models.UserColumns.ID)...)
	}
	queryMods = append(queryMods, StringFilterToMods(m.FirstName, models.UserColumns.FirstName)...)
	queryMods = append(queryMods, StringFilterToMods(m.LastName, models.UserColumns.LastName)...)
	queryMods = append(queryMods, StringFilterToMods(m.Username, models.UserColumns.Username)...)
	queryMods = append(queryMods, StringFilterToMods(m.Password, models.UserColumns.Password)...)
	queryMods = append(queryMods, StringFilterToMods(m.Email, models.UserColumns.Email)...)
	queryMods = append(queryMods, StringFilterToMods(m.Mobile, models.UserColumns.Mobile)...)
	queryMods = append(queryMods, StringFilterToMods(m.Phone, models.UserColumns.Phone)...)
	queryMods = append(queryMods, StringFilterToMods(m.Address, models.UserColumns.Address)...)
	queryMods = append(queryMods, BooleanFilterToMods(m.Active, models.UserColumns.Active)...)
	queryMods = append(queryMods, IntFilterToMods(m.LastLogin, models.UserColumns.LastLogin)...)
	queryMods = append(queryMods, IntFilterToMods(m.LastPasswordChange, models.UserColumns.LastPasswordChange)...)
	queryMods = append(queryMods, StringFilterToMods(m.Token, models.UserColumns.Token)...)
	queryMods = append(queryMods, RoleWhereSubqueryToMods(m.Role, models.UserColumns.RoleID)...)
	queryMods = append(queryMods, CompanyWhereSubqueryToMods(m.Company, models.UserColumns.CompanyID)...)
	queryMods = append(queryMods, LocationWhereSubqueryToMods(m.Location, models.UserColumns.LocationID)...)
	queryMods = append(queryMods, IntFilterToMods(m.CreatedAt, models.UserColumns.CreatedAt)...)
	queryMods = append(queryMods, IntFilterToMods(m.DeletedAt, models.UserColumns.DeletedAt)...)
	queryMods = append(queryMods, IntFilterToMods(m.UpdatedAt, models.UserColumns.UpdatedAt)...)
	queryMods = append(queryMods, CommentWhereSubqueryToMods(m.Comments, "")...)
	queryMods = append(queryMods, FollowerWhereSubqueryToMods(m.FolloweeFollowers, "")...)
	queryMods = append(queryMods, FollowerWhereSubqueryToMods(m.FollowerFollowers, "")...)
	queryMods = append(queryMods, PostWhereSubqueryToMods(m.Posts, "")...)
	if m.Or != nil {
		queryMods = append(queryMods, qm.Or2(qm.Expr(UserWhereToMods(m.Or, true)...)))
	}
	if m.And != nil {
		queryMods = append(queryMods, qm.Expr(UserWhereToMods(m.And, true)...))
	}
	return queryMods
}
